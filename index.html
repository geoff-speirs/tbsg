<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title></title>
</head>

<body>
<p id="map" style="white-space: pre; font-family:monospace;">
  Starting...
</p>
<p>
  <button type="button" id="h_button">H</button>
  <button type="button" id="j_button">J</button>
  <button type="button" id="k_button">K</button>
  <button type="button" id="l_button">L</button>
</p>
<p style="font-family:monospace;">HP: <span id="hp"></span></p>
<p style="font-family:monospace;">Hunger: <span id="hunger"></span></p>

<script>
{
/*
This whole project is in one file for the following reasons:
- Making dev environments as close as possible to production. As a single file you are developing on exactly the same environment that gets loaded in prod.
- Needing less tooling. Most browsers don't let you load other files uness it is in a hosted environment. By using a single file we can load and test the project by opening the single file in any browser.
- Simplicity. By keeping all code in one file we minimise any knowledge required outside of html, css and JavaScript.

Security concerns for having local scripts:
- Local scripts can be flagged as a security risk, however given that this project does not load any external resources I beleive the risk does not exist. If you fork this project and plan to make changes then please take this into consideration.

On unit tests:
- All unit tests for game logic should be triggered by issuing commands to the game. eg moving the player only should be tested via the Game class, not in the Player class. This is because we consider the Game to be the unit of logic we are promising everyone will work. The only unit tests we should write for other classes that comprise the game are for their constructors, as game objects can be ibstantiated outside of the game.
*/
  const assert = (fact, message = "Assertion failed.") => {
    if (!fact){
      throw new Error(message);
    }
  }
  {
    const errMsg = "assert should throw error if fact is false";
    class TestAssertError extends Error {}
    try {
      assert(false);
      throw new TestAssertError(errMsg);
    } catch (e) {
      if (e instanceof TestAssertError){
        throw new Error(errMsg);
      }
    }
  }
  {
    const errMsg = "assert should not throw error if fact is true";
    try {
      assert(true);
    } catch (e) {
      throw new Error(errMsg);
    }
  }
  {
    const errMsg = "assert should throw error with specified error message";
    const testMsg = "test error message";
    try {
      assert(false, testMsg);
    } catch (e) {
      const msgCorrect = e.message === testMsg;
      if (!msgCorrect){
        throw new Error(errMsg);
      }
    }
  }
  
  const throwsError = (func, errorClass) => {
    try {
      func();
      return false;
    } catch (e) {
      return (e instanceof errorClass);
    }
  }
  {
    const errMsg = "throwsError should return true if correct Error was thrown.";
    const throws = throwsError(()=>{
        throw new Error();
      }, Error);
    assert(throws, errMsg);
  }
  {
    const errMsg = "throwsError should return false if wrong error was thrown.";
    class TestError extends Error {}
    const throws = throwsError(() => {
        throw new Error();
      }, TestError);
    assert(!throws, errMsg);
  }
  {
    const errMsg = "throwsError should return false if no error was thrown.";
    const throws = throwsError(()=>{}, Error);
    assert (!throws, errMsg);
  }
    
  class PlayerValidationError extends Error {}
  class Player {
    constructor(down = 0, right = 0, maxHp = 100, maxHunger = 100){
      this.down = down;
      this.right = right;
      this.maxHp = maxHp;
      this.hp = maxHp;
      this.maxHunger = maxHunger;
      this.hunger = maxHunger;
    }
    moveRight(){
      this.right += 1;
      this.reduceHunger();
    }
    moveLeft(){
      this.right -= 1;
      this.reduceHunger();
    }
    moveDown(){
      this.down += 1;
      this.reduceHunger();
    }
    moveUp(){
      this.down -= 1;
      this.reduceHunger();
    }
    reduceHunger(){
      this.hunger -= 1;
      if (this.hunger < 0){
        this.hunger = 0;
      }
    }
  }
  
  const Command = {
    MoveRight: Symbol("MoveRight"),
    MoveLeft: Symbol("MoveLeft"),
    MoveDown: Symbol("MoveDown"),
    MoveUp: Symbol("MoveUp")
  }
  
  class Game {
    constructor(map, player){
      this.map = map;
      this.player = player;
    }
    
    movePlayerRight(){
      if(this.player.right + 1 >= this.map[this.player.down].length){
        return;
      }
      this.player.moveRight();
    }
    
    movePlayerLeft(){
      if(this.player.right - 1 < 0){
        return;
      }
      this.player.moveLeft();
    }
    
    movePlayerDown(){
      if(this.player.down + 1 >= this.map.length){
        return;
      }
      this.player.moveDown();
    }
    
    movePlayerUp() {
      if (this.player.down - 1 < 0) {
        return;
      }
      this.player.moveUp();
    }
    
    update(command){
      if (command === Command.MoveRight){
        this.movePlayerRight();
      } else if (command === Command.MoveLeft){
        this.movePlayerLeft();
      } else if (command === Command.MoveDown){
        this.movePlayerDown();
      } else if (command === Command.MoveUp) {
        this.movePlayerUp();
      }
    }
  }
  {
    const errMsg = "Move command should move player";
    [
      [[0, 1], [0, 0], Command.MoveRight, "right"],
      [[0, 0], [0, 1], Command.MoveLeft, "left"],
      [[1, 0], [0, 0], Command.MoveDown, "down"],
      [[0, 0], [1, 0], Command.MoveUp, "up"]
    ].forEach(([[expectedDown, expectedRight], [startX, startY], command, direction]) => {
      const player = new Player(startX, startY);
      const game = new Game([[1,2],[3,4]], player);
      game.update(command);
      assert(expectedDown === game.player.down, `${errMsg} ${direction}`);
      assert(expectedRight === game.player.right, `${errMsg} ${direction}`);
    });
  }
  {
    const errMsg = "Player shouldn't move outside of map when moving";
    [
      [Command.MoveRight, "right"],
      [Command.MoveLeft, "left"],
      [Command.MoveDown, "down"],
      [Command.MoveUp, "up"]
    ].forEach(([command, direction]) => {
      const player = new Player(0, 0);
      const game = new Game([[0]], player);
      game.update(command);
      assert(0 === game.player.right, `${errMsg} ${direction}`);
      assert(0 === game.player.down, `${errMsg} ${direction}`);
    });
  }
  {
    const errMsg = "moving should reduce hunger";
    
    [Command.MoveRight, Command.MoveLeft, Command.MoveDown, Command.MoveUp].forEach(()=>{
      const player = new Player(1, 1, 100, 100);
      const game = new Game([[0, 0, 0], [0, 0, 0], [0, 0, 0]], player);
      game.update(Command.MoveRight);
      assert(99 === game.player.hunger, errMsg);
    });
  }
  {
    const errMsg = "hunger should not reduce to below 0";
    const player = new Player(0, 0, 100, 0);
    const game = new Game([[0, 0]], player);
    game.update(Command.MoveRight);
    assert(0 === game.player.hunger, errMsg);
  }
  
  const Display = {
    GroundTile: Symbol("GroundTile"),
    PlayerTile: Symbol("PlayerTile")
  }
  
  const generateTiles = (game) => {
    var tiles = game.map.map((lines) => lines.map(tile => Display.GroundTile));
    tiles[game.player.down][game.player.right] = Display.PlayerTile;
    return tiles;
  };
  {
    const errMsg = "should generate ground tiles";
    [
      [0, 0], [1, 1]
    ].forEach(([down, right]) => {
      const result = generateTiles(new Game([[0, 1], [2, 3]], new Player(0, 1)));
      assert(Display.GroundTile === result[down][right], errMsg);
    });
  }
  {
    const errMsg = "should generate player tile";
    [
      [0,0], [1,1]
    ].forEach(([down, right]) => {
      const result = generateTiles(new Game([[1,2],[3,4]], new Player(down, right)));
      assert(Display.PlayerTile === result[down][right], errMsg);
    });
  }
  
  //Below here is I/O code that won't be tested
  const render = (tiles) => {
    var tiles = tiles.map((lines) => lines.map(tile => {
        switch(tile){
          case Display.GroundTile:
          return ",";
          case Display.PlayerTile:
          return "@";
        }
      }
      ).join("")).join("\n");
    return tiles;
  };
  
  const mapElem = document.getElementById("map");
  const hpElem = document.getElementById("hp");
  const hungerElem = document.getElementById("hunger");
  class Engine {
    constructor(game){
      this.game = game;
    }
    
    progress(command){
      game.update(command);
      this.render();
    }
    
    render(){
      const tiles = generateTiles(game);
      mapElem.textContent = render(tiles);
      hpElem.textContent = game.player.maxHp;
      hungerElem.textContent = `${game.player.hunger}/${game.player.maxHunger}`;
    }
  }
  
  const player = new Player(0, 0, 100, 100);
  const game = new Game([[0,0,0,0,0], [0,0,0,0,0],[0,0,0,0,0], [0,0,0,0,0],[0,0,0,0,0]], player);
  const engine = new Engine(game);
  engine.render();
  
  document.addEventListener("keydown", (event) => {
    switch (event.code) {
      case "KeyH":
        game.update(Command.MoveLrft);
        break;
      case "KeyJ":
        game.update(Command.MoveDown);
        break;
      case "KeyK":
        game.update(Command.MoveUp);
        break;
      case "KeyL":
        game.update(Command.MoveRight);
        break;
    }
  });
  
  document.getElementById("h_button").onclick = (event) => {
    engine.progress(Command.MoveLeft)
  };  
  document.getElementById("j_button").onclick = (event) => {
    engine.progress(Command.MoveDown)
  };  
  document.getElementById("k_button").onclick = (event) => {
    engine.progress(Command.MoveUp)
  };  
  document.getElementById("l_button").onclick = (event) => {
    engine.progress(Command.MoveRight)
  };
}
  
  
</script>
</body>

</html>