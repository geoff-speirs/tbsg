<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title></title>
</head>

<body style="font-family:monospace;">
<p id="map" style="white-space: pre;">
  Starting...
</p>
<p>
  <button type="button" id="h_button">H</button>
  <button type="button" id="j_button">J</button>
  <button type="button" id="k_button">K</button>
  <button type="button" id="l_button">L</button>
  <button type="button" id="eat_button">Eat</button>
</p>
<p>HP: <span id="hp"></span></p>
<p>Hunger: <span id="hunger"></span></p>
<p>
  Inventory:
  <ul id="inventory_list">
  </ul>
</p>
<script>
{
/*
This whole profject is in one file for the following reasons:
- Making dev environments as close as possible to production. As a single file you are developing on exactly the same environment that gets loaded in prod.
- Needing less tooling. Most browsers don't let you load other files uness it is in a hosted environment. By using a single file we can load and test the project by opening the single file in any browser.
- Simplicity. By keeping all code in one file we minimise any knowledge required outside of html, css and JavaScript.

Security concerns for having local scripts:
- Local scripts can be flagged as a security risk, however given that this project does not load any external resources I beleive the risk does not exist. If you fork this project and plan to make changes then please take this into consideration.

On unit tests:
- All unit tests for game logic should be triggered by issuing commands to the game. eg moving the player only should be tested via the Game class, not in the Player class. This is because we consider the Game to be the unit of logic we are promising everyone will work. 
*/
  const assert = (fact, message = "Assertion failed.") => {
    if (!fact){
      throw new Error(message);
    }
  }
  {
    const errMsg = "assert should throw error if fact is false";
    class TestAssertError extends Error {}
    try {
      assert(false);
      throw new TestAssertError(errMsg);
    } catch (e) {
      if (e instanceof TestAssertError){
        throw new Error(errMsg);
      }
    }
  }
  {
    const errMsg = "assert should not throw error if fact is true";
    try {
      assert(true);
    } catch (e) {
      throw new Error(errMsg);
    }
  }
  {
    const errMsg = "assert should throw error with specified error message";
    const testMsg = "test error message";
    try {
      assert(false, testMsg);
    } catch (e) {
      const msgCorrect = e.message === testMsg;
      if (!msgCorrect){
        throw new Error(errMsg);
      }
    }
  }
  
  const throwsError = (func, errorClass) => {
    try {
      func();
      return false;
    } catch (e) {
      return (e instanceof errorClass);
    }
  }
  {
    const errMsg = "throwsError should return true if correct Error was thrown.";
    const throws = throwsError(()=>{
        throw new Error();
      }, Error);
    assert(throws, errMsg);
  }
  {
    const errMsg = "throwsError should return false if wrong error was thrown.";
    class TestError extends Error {}
    const throws = throwsError(() => {
        throw new Error();
      }, TestError);
    assert(!throws, errMsg);
  }
  {
    const errMsg = "throwsError should return false if no error was thrown.";
    const throws = throwsError(()=>{}, Error);
    assert (!throws, errMsg);
  }
    
  class PlayerValidationError extends Error {}
  class Player {
    constructor(down = 0, right = 0, maxHp = 100, maxHunger = 100, inventory = []){
      this.down = down;
      this.right = right;
      this.maxHp = maxHp;
      this.hp = maxHp;
      this.maxHunger = maxHunger;
      this.hunger = maxHunger;
      this.inventory = inventory;
    }
    moveRight(){
      this.right += 1;
      this.applyHunger();
    }
    moveLeft(){
      this.right -= 1;
      this.applyHunger();
    }
    moveDown(){
      this.down += 1;
      this.applyHunger();
    }
    moveUp(){
      this.down -= 1;
      this.applyHunger();
    }
    applyHunger(){
      this.hunger -= 1;
      if (this.hunger < 0){
        this.hunger = 0;
      }
      if (this.hunger === 0){
        this.hp -= 1;
      }
    }
    eatFood(food){
      this.hunger += food.sustenance;
      if (this.hunger >= this.maxHunger){
        this.hunger = this.maxHunger;
      }
      this.inventory.splice(this.inventory.indexOf(food), 1);
    }
  }
  
  class Food{
    constructor(sustenance = 0){
      this.sustenance = sustenance;
    }
  }
  
  class MoveRightCommand {}
  class MoveLeftCommand {}
  class MoveDownCommand {}
  class MoveUpCommand {}
  class EatFoodCommand {
    constructor(food){
      this.food = food;
    }
  }
  
  class Game {
    constructor(map = [[]], player = new Player()){
      this.map = map;
      this.player = player;
      this.gameOver = false;
    }
    
    movePlayerRight(){
      if(this.player.right + 1 >= this.map[this.player.down].length){
        return;
      }
      this.player.moveRight();
    }
    
    movePlayerLeft(){
      if(this.player.right - 1 < 0){
        return;
      }
      this.player.moveLeft();
    }
    
    movePlayerDown(){
      if(this.player.down + 1 >= this.map.length){
        return;
      }
      this.player.moveDown();
    }
    
    movePlayerUp() {
      if (this.player.down - 1 < 0) {
        return;
      }
      this.player.moveUp();
    }
    handlePlayerCommands(command, food){
      if (command instanceof MoveRightCommand){
        this.movePlayerRight();
      } else if (command instanceof MoveLeftCommand){
        this.movePlayerLeft();
      } else if (command instanceof MoveDownCommand){
        this.movePlayerDown();
      } else if (command instanceof MoveUpCommand) {
        this.movePlayerUp();
      } else if (command instanceof EatFoodCommand){
        this.player.eatFood(command.food);
      }
    }
    checkForGameOver(){
      if (this.player.hp <= 0){
        this.gameOver = true;
      }
    }
    
    update(command, item){
      if (this.gameOver){
        return;
      }
      this.handlePlayerCommands(command, item);
      this.checkForGameOver();
    }
  }
  {
    const errMsg = "Move command should move player";
    [
      [[0, 1], [0, 0], new MoveRightCommand(), "right"],
      [[0, 0], [0, 1], new MoveLeftCommand(), "left"],
      [[1, 0], [0, 0], new MoveDownCommand(), "down"],
      [[0, 0], [1, 0], new MoveUpCommand(), "up"]
    ].forEach(([[expectedDown, expectedRight], [startX, startY], command, direction]) => {
      const player = new Player(startX, startY);
      const game = new Game([[1,2],[3,4]], player);
      game.update(command);
      assert(expectedDown === game.player.down, `${errMsg} ${direction}`);
      assert(expectedRight === game.player.right, `${errMsg} ${direction}`);
    });
  }
  {
    const errMsg = "Player shouldn't move outside of map when moving";
    [
      [new MoveRightCommand(), "right"],
      [new MoveLeftCommand(), "left"],
      [new MoveDownCommand(), "down"],
      [new MoveUpCommand(), "up"]
    ].forEach(([command, direction]) => {
      const player = new Player(0, 0);
      const game = new Game([[0]], player);
      game.update(command);
      assert(0 === game.player.right, `${errMsg} ${direction}`);
      assert(0 === game.player.down, `${errMsg} ${direction}`);
    });
  }
  {
    const errMsg = "moving should reduce hunger";
    
    [new MoveRightCommand(), new MoveLeftCommand(), new MoveDownCommand(), new MoveUpCommand()].forEach((command)=>{
      const player = new Player(1, 1, 100, 100);
      const game = new Game([[0, 0, 0], [0, 0, 0], [0, 0, 0]], player);
      game.update(command);
      assert(99 === game.player.hunger, errMsg);
    });
  }
  {
    const errMsg = "hunger should not reduce for failed move"
    const player = new Player(0, 0, 100, 100);
    const game = new Game([[0]], player);
    game.update(new MoveRightCommand());
    assert(100 === game.player.hunger, errMsg);
  }
  {
    const errMsg = "hunger should not reduce to below 0";
    const player = new Player(0, 0, 100, 0);
    const game = new Game([[0, 0]], player);
    game.update(new MoveRightCommand());
    assert(0 === game.player.hunger, errMsg);
  }
  {
    const errMsg = "hp should reduce by 1 when hunger is 0"
    const player = new Player(0, 0, 100, 0);
    const game = new Game([[0, 0]], player);
    game.update(new MoveRightCommand());
    assert(99 === game.player.hp, errMsg);
  }
  {
    const errMsg = "hp should not reduce when hunger is not 0"
    const player = new Player(0, 0, 100, 100);
    const game = new Game([[0, 0]], player);
    game.update(new MoveRightCommand());
    assert(100 === game.player.hp, errMsg);
  }
  {
    const errMsg = "game should finish if hp is 0"
    const player = new Player(0, 0, 1, 0);
    const game = new Game([[0, 0]], player);
    game.update(new MoveRightCommand());
    assert(true === game.gameOver, errMsg);
  }
  {
    const errMsg = "commands shouldnt process when game over";
    const player = new Player(0, 0, 100, 100);
    const game = new Game([[0, 0]], player);
    game.gameOver = true;
    game.update(new MoveRightCommand());
    assert(100 === game.player.hunger, errMsg);
  }
  {
    const errMsg = "using item should remove it from inventory";
    const food = new Food();
    const player = new Player(0,0,100,100,[food]);
    const game = new Game([[0, 0]], player);
    game.update(new EatFoodCommand(food));
    assert(game.player.inventory.length === 0, errMsg);
  }
  {
    const errMsg = "eating food should increase hunger by food sustenance"
    const food = new Food(50);
    const player = new Player(0,0,100,100,[food]);
    player.hunger = 1;
    const game = new Game([[0, 0]], player);
    game.update(new EatFoodCommand(food));
    assert(game.player.hunger === 51, errMsg);
  }
  {
    const errMsg = "hunger should not increase above max hunger"
    const food = new Food(50);
    const player = new Player(0,0,100,100,[food]);
    const game = new Game([[0, 0]], player);
    game.update(new EatFoodCommand(food));
    assert(game.player.hunger === 100, errMsg);
  }
  //create ui to use inventory
  //try code block instead of monospace
  
  const Display = {
    GroundTile: Symbol("GroundTile"),
    PlayerTile: Symbol("PlayerTile")
  }
  
  const generateTiles = (game) => {
    var tiles = game.map.map((lines) => lines.map(tile => Display.GroundTile));
    tiles[game.player.down][game.player.right] = Display.PlayerTile;
    return tiles;
  };
  {
    const errMsg = "should generate ground tiles";
    [
      [0, 0], [1, 1]
    ].forEach(([down, right]) => {
      const result = generateTiles(new Game([[0, 1], [2, 3]], new Player(0, 1)));
      assert(Display.GroundTile === result[down][right], errMsg);
    });
  }
  {
    const errMsg = "should generate player tile";
    [
      [0,0], [1,1]
    ].forEach(([down, right]) => {
      const result = generateTiles(new Game([[1,2],[3,4]], new Player(down, right)));
      assert(Display.PlayerTile === result[down][right], errMsg);
    });
  }
  
  //Below here is I/O code that won't be tested
  const render = (tiles) => {
    var tiles = tiles.map((lines) => lines.map(tile => {
        switch(tile){
          case Display.GroundTile:
          return ",";
          case Display.PlayerTile:
          return "@";
        }
      }
      ).join("")).join("\n");
    return tiles;
  };
  
  const mapElem = document.getElementById("map");
  const hpElem = document.getElementById("hp");
  const hungerElem = document.getElementById("hunger");
  const inventoryElem = document.getElementById("inventory_list");
  class Engine {
    constructor(game){
      this.game = game;
    }
    
    progress(command){
      game.update(command);
      this.render();
    }
    
    render(){
      const tiles = generateTiles(game);
      mapElem.textContent = render(tiles);
      hpElem.textContent = `${game.player.hp}/${game.player.maxHp}`;
      hungerElem.textContent = `${game.player.hunger}/${game.player.maxHunger}`;
      
      const inventoryListItems = engine.game.player.inventory.map(item => {
        const li = document.createElement("li");
        li.textContent = "Food";
        return li;
      });
      inventoryElem.replaceChildren(...inventoryListItems);
    }
  }
  const food = new Food(5);
  const player = new Player(0, 0, 10, 10, [food, food, food]);
  const game = new Game([[0,0,0,0,0], [0,0,0,0,0],[0,0,0,0,0], [0,0,0,0,0],[0,0,0,0,0]], player);
  const engine = new Engine(game);
  engine.render();
  
  document.addEventListener("keydown", (event) => {
    switch (event.code) {
      case "KeyH":
        game.update(new MoveLeftCommand());
        break;
      case "KeyJ":
        game.update(new MoveDownCommand());
        break;
      case "KeyK":
        game.update(new MoveUpCommand());
        break;
      case "KeyL":
        game.update(new MoveRightCommand());
        break;
    }
  });
  
  document.getElementById("h_button").onclick = (event) => {
    engine.progress(new MoveLeftCommand())
  };  
  document.getElementById("j_button").onclick = (event) => {
    engine.progress(new MoveDownCommand())
  };  
  document.getElementById("k_button").onclick = (event) => {
    engine.progress(new MoveUpCommand())
  };  
  document.getElementById("l_button").onclick = (event) => {
    engine.progress(new MoveRightCommand())
  };
  document.getElementById("eat_button").onclick = (event) => {
    const food = engine.game.player.inventory.find(((item) => item instanceof Food))
    if (food){
      engine.progress(new EatFoodCommand(food));
    }
  };
}
  
  
</script>
</body>

</html>