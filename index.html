<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title></title>
</head>

<body>
<p id="test_failures" style="white-space: pre;">
</p>
<p id="map" style="white-space: pre;">
  Starting...
</p>
<p>
  <button type="button" id="h_button">H</button>
  <button type="button" id="j_button">J</button>
  <button type="button" id="k_button">K</button>
  <button type="button" id="l_button">L</button>
</p>

<script>
{
  class TypeError extends Error {}
  const checkTypes = (...varPairs) => {
    varPairs.forEach(([type, variable]) => {
      if (variable instanceof type) {
        return;
      } else if (typeof(variable) === "object"){
        throw new TypeError(`Expected ${variable} to be of type ${type}`);
      }
      if (type === String && typeof(variable) === "string") return;
      if (type === Boolean && typeof(variable) === "boolean") return;
      if (type === Number && typeof(variable) === "number") return;
      if (type === BigInt && typeof(variable) === "bigint") return;
      if (type === Symbol && typeof(variable) === "symbol") return;
      if (type === Function && typeof(variable) === "function") return;
      throw new TypeError(`Expected ${variable} to be of type ${type}`)
    });
  };
  
  class NothingThrownError extends Error {}
  class WrongErrorError extends Error {}
  const assertThrows = (func, errorClass) => {
    checkTypes([Function, func], [Function, errorClass]);
    try {
      func();
      throw new NothingThrownError();
    } catch (e) {
      if (!(e instanceof errorClass)){
        throw new WrongErrorError(`Expected error of class ${errorClass.name} to be thrown.`);
      }
      if (e instanceof NothingThrownError){
        throw e;
      }
    }
  }
  {
    const errMsg = "assertThrow shouldn't throw Error if correct Error was thrown.";
    try {
      assertThrows(()=>{
        throw new Error();
      }, Error);
    } catch {
      throw new Error(errMsg);
    }
  }
  {
    const errMsg = "assertThrows should throw WrongErrorError if wrong error was thrown.";
    class TestError extends Error {}
    try {
      assertThrows(() => {
        throw new Error();
      }, TestError);
    } catch (e) {
      if (!(e instanceof WrongErrorError)){
        throw new Error(errMsg);
      }
    }
  }
  {
    const errMsg = "assertThrows should throw NothingThrownError no error was thrown.";
    var errThrown = false;
    try {
      assertThrows(()=>{}, Error);
    } catch (e) {
      errThrown = true;
      if (!(e instanceof NothingThrownError)){
        throw new Error(errMsg);
      }
    }
    if (!errThrown){
      throw new Error(errMsg);
    }
  }
  {
    const errMsg = "checkTypes should not throw error if type matches.";
    try {
      checkTypes([Error, new Error()]);
    } catch (e) {
      throw new Error(errMsg);
    }
  }
  {
    const errMsg = "checkTypes should throw error if types don't match";
    assertThrows(()=>{
      checkTypes([Error, new Date()]);
    }, TypeError);
  }
  {
    const errMsg = "checkTypes should not throw error for primitives";
    [[String, "test"], [Number, 123], [Boolean , false], [BigInt, 1n], [Symbol, Symbol()], [Function, () => {}]].forEach((varPair) => {
      try {
        checkTypes(varPair);
      } catch (e) {
        throw new Error(errMsg);
      }
    });
  }
  
    
  class PlayerPosError extends Error {}
  class Player {
    constructor(down, right){
      if (down < 0 || right < 0) {
        throw new PlayerPosError();
      }
      this.down = down;
      this.right = right;
    }
    moveRight(){
      this.right += 1;
    }
    moveLeft(){
      this.right -= 1;
    }
    moveDown(){
      this.down += 1;
    }
    moveUp(){
      this.down -= 1;
    }
  }
  
  const Command = {
    MoveRight: "MoveRight",
    MoveLeft: "MoveLeft",
    MoveDown: "MoveDown",
    MoveUp: "MoveUp"
  }
  
  class Game {
    constructor(map, player){
      this.map = map;
      this.player = player;
    }
    update(command){
      if (command === Command.MoveRight){
        this.player.moveRight();
      } else if (command === Command.MoveLeft){
        this.player.moveLeft();
      } else if (command === Command.MoveDown){
        this.player.moveDown();
      } else if (command === Command.MoveUp) {
        this.player.moveUp();
      }
    }
  }
  
  const Display = {
    GroundTile: "GroundTile",
    PlayerTile: "PlayerTile"
  }
  
  const generateTiles = (game) => {
    var tiles = game.map.map((lines) => lines.map(tile => Display.GroundTile));
    tiles[game.player.down][game.player.right] = Display.PlayerTile;
    return tiles;
  };
  
  const render = (tiles) => {
    var tiles = tiles.map((lines) => lines.map(tile => {
        switch(tile){
          case Display.GroundTile:
          return "G";
          case Display.PlayerTile:
          return "P";
        }
      }
      ).join("")).join("\n");
    return tiles;
  };
  
  {
    const assertEqual = (expected, result, message) => {
      if (expected !== result){
        const detailMsg = message ?? "";
        throw new Error(`${detailMsg}: Expected ${result} to be ${expected}`);
      }
    };

    tests = [
      ["generating player tile",
        [
          [0,0], [1,1]
        ],
        ([down, right]) => {
          const result = generateTiles(new Game([[1,2],[3,4]], new Player(down, right)));
          assertEqual(Display.PlayerTile, result[down][right]);
        }
      ],
      ["generating ground tiles",
        [
          [0,0], [1,1]
        ],
        ([down, right]) => {
          const result = generateTiles(new Game([[0,1], [2,3]], new Player(0, 1)));
          assertEqual(Display.GroundTile, result[down][right]);
        }
      ],
      ["rendering tiles",
        [
          ["G\nP", [[Display.GroundTile],[Display.PlayerTile]]
          ]
        ],
        ([expected, tiles]) => {
          const result = render(tiles);
          assertEqual(expected, result);
        }
      ],
      ["moving player",
        [
          [[0, 1], [0, 0], Command.MoveRight, "right"],
          [[0, 0], [0, 1], Command.MoveLeft, "left"],
          [[1, 0], [0, 0], Command.MoveDown, "down"],
          [[0, 0], [1, 0], Command.MoveUp, "up"]
        ],
        ([[expectedDown, expectedRight], [startX, startY], command, message]) => {
          const player = new Player(startX, startY);
          const game = new Game([[1,2],[3,4]], player);
          game.update(command, player);
          assertEqual(expectedDown, game.player.down, message);
          assertEqual(expectedRight, game.player.right, message);
        }
      ],
      ["validating non-negative player start pos",
        [[0, -1], [-1, 0]],
        ([right, down]) => {
          assertThrows(() => {
            new Player(right, down);
          }, PlayerPosError);
        }
      ]
    ];
  
    var failures = [];
    tests.forEach(([description, dataList, test]) => dataList.forEach((data) => {
        try{
          test(data);
        }
        catch (error) {
          failures.push(`Error ${description} ${error.message}`);
        }
      })
    );
    document.getElementById("test_failures").textContent = failures.join("\n");
  }
  
  const mapElem = document.getElementById("map");
  class Engine {
    constructor(game){
      this.game = game;
      const tiles = generateTiles(game);
      mapElem.textContent = render(tiles);//render initial
    }
    
    progress(command){
      game.update(command);
      const tiles = generateTiles(game);
      mapElem.textContent = render(tiles);
    }
  }
  
  const player = new Player(0, 0);
  const game = new Game([["T", "T"], ["T", "T"]], player);
  const engine = new Engine(game);
  const tiles = generateTiles(game);
  mapElem.textContent = render(tiles);
  
  document.addEventListener("keydown", (event) => {
    switch (event.code) {
      case "KeyH":
        game.update(Command.MoveLrft);
        break;
      case "KeyJ":
        game.update(Command.MoveDown);
        break;
      case "KeyK":
        game.update(Command.MoveUp);
        break;
      case "KeyL":
        game.update(Command.MoveRight);
        break;
    }
  });
  
  document.getElementById("h_button").onclick = (event) => {
    engine.progress(Command.MoveLeft)
  };  
  document.getElementById("j_button").onclick = (event) => {
    engine.progress(Command.MoveDown)
  };  
  document.getElementById("k_button").onclick = (event) => {
    engine.progress(Command.MoveUp)
  };  
  document.getElementById("l_button").onclick = (event) => {
    engine.progress(Command.MoveRight)
  };
}
  
  
</script>
</body>

</html>