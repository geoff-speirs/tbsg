<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title></title>
</head>

<body>
<p id="test_failures" style="white-space: pre;">
</p>
<p id="map" style="white-space: pre;">
  Starting...
</p>
<p>
  <button type="button" id="h_button">H</button>
  <button type="button" id="j_button">J</button>
  <button type="button" id="k_button">K</button>
  <button type="button" id="l_button">L</button>
</p>

<script>
{
/*
This whole project is in one file for the following reasons:
- Making dev environments as close as possible to production. As a single file you are developing on exactly the same environment that gets loaded in prod.
- Needing less tooling. Most browsers don't let you load other files uness it is in a hosted environment. By using a single file we can load and test the project by opening the single file in any browser.
- Simplicity. By keeping all code in one file we minimise any knowledge required outside of html, css and JavaScript.

Security concerns for having local scripts:
- Local scripts can be flagged as a security risk, however given that this project does not load any external resources I beleive the risk does not exist. If you fork this project and plan to make changes then please take this into consideration.

On unit tests:
- All unit tests for game logic should be triggered by issuing commands to the game. eg moving the player only should be tested via the Game class, not in the Player class. This is because we consider the Game to be the unit of logic we are promising everyone will work. The only unit tests we should write for other classes that comprise the game are for their constructors, as game objects can be ibstantiated outside of the game.
*/
  class TypeError extends Error {}
  const checkTypes = (...varPairs) => {
    varPairs.forEach(([type, variable]) => {
      if (variable instanceof type) {
        return;
      } else if (typeof(variable) === "object"){
        throw new TypeError(`Expected ${variable} to be of type ${type}`);
      }
      if (type === String && typeof(variable) === "string") return;
      if (type === Boolean && typeof(variable) === "boolean") return;
      if (type === Number && typeof(variable) === "number") return;
      if (type === BigInt && typeof(variable) === "bigint") return;
      if (type === Symbol && typeof(variable) === "symbol") return;
      if (type === Function && typeof(variable) === "function") return;
      throw new TypeError(`Expected ${variable} to be of type ${type}`)
    });
  };

  const assert = (fact, message = "Assertion failed.") => {
    checkTypes([Boolean, fact], [String, message]);
    if (!fact){
      throw new Error(message);
    }
  }
  {
    const errMsg = "assert should throw error if fact is false";
    class TestAssertError extends Error {}
    try {
      assert(false);
      throw new TestAssertError(errMsg);
    } catch (e) {
      if (e instanceof TestAssertError){
        throw new Error(errMsg);
      }
    }
  }
  {
    const errMsg = "assert should not throw error if fact is true";
    try {
      assert(true);
    } catch (e) {
      throw new Error(errMsg);
    }
  }
  {
    const errMsg = "assert should throw error with specified error message";
    const testMsg = "test error message";
    try {
      assert(false, testMsg);
    } catch (e) {
      const msgCorrect = e.message === testMsg;
      if (!msgCorrect){
        throw new Error(errMsg);
      }
    }
  }
  
  const throwsError = (func, errorClass) => {
    checkTypes([Function, func], [Function, errorClass]);
    try {
      func();
      return false;
    } catch (e) {
      return (e instanceof errorClass);
    }
  }
  {
    const errMsg = "throwsError should return true if correct Error was thrown.";
    const throws = throwsError(()=>{
        throw new Error();
      }, Error);
    assert(throws, errMsg);
  }
  {
    const errMsg = "throwsError should return false if wrong error was thrown.";
    class TestError extends Error {}
    const throws = throwsError(() => {
        throw new Error();
      }, TestError);
    assert(!throws, errMsg);
  }
  {
    const errMsg = "throwsError should return false if no error was thrown.";
    const throws = throwsError(()=>{}, Error);
    assert (!throws, errMsg);
  }
  {
    const errMsg = "checkTypes should not throw error if type matches.";
    try {
      checkTypes([Error, new Error()]);
    } catch (e) {
      throw new Error(errMsg);
    }
  }
  {
    const errMsg = "checkTypes should throw error if types don't match";
    const throws = throwsError(()=>{
      checkTypes([Error, new Date()]);
    }, TypeError);
    assert(throws, errMsg);
  }
  {
    const errMsg = "checkTypes should not throw error for primitives";
    [[String, "test"], [Number, 123], [Boolean , false], [BigInt, 1n], [Symbol, Symbol()], [Function, () => {}]].forEach((varPair) => {
      try {
        checkTypes(varPair);
      } catch (e) {
        throw new Error(errMsg);
      }
    });
  }
    
  class PlayerValidationError extends Error {}
  class Player {
    constructor(down, right){
      if (down < 0 || right < 0) {
        throw new PlayerValidationError("Player must have positive position.");
      }
      this.down = down;
      this.right = right;
    }
    moveRight(){
      this.right += 1;
    }
    moveLeft(){
      this.right -= 1;
    }
    moveDown(){
      this.down += 1;
    }
    moveUp(){
      this.down -= 1;
    }
  }
  {
    const errMsg = "player cannot be constructed with negative position.";
    [[-1, -1], [0, -1], [-1, 0]].forEach(([down, right])=>{
      const throws = throwsError(()=>{
        new Player(down, right);
      }, PlayerValidationError);
      assert(throws, errMsg);
    });
  }
  
  const Command = {
    MoveRight: Symbol("MoveRight"),
    MoveLeft: Symbol("MoveLeft"),
    MoveDown: Symbol("MoveDown"),
    MoveUp: Symbol("MoveUp")
  }
  
  class Game {
    constructor(map, player){
      checkTypes([Array, map], [Player, player]);
      this.map = map;
      this.player = player;
    }
    update(command){
      checkTypes([Symbol, command]);
      if (command === Command.MoveRight){
        this.player.moveRight();
      } else if (command === Command.MoveLeft){
        this.player.moveLeft();
      } else if (command === Command.MoveDown){
        this.player.moveDown();
      } else if (command === Command.MoveUp) {
        this.player.moveUp();
      }
    }
  }
  {
    const errMsg = "Move command should move player";
      [
        [[0, 1], [0, 0], Command.MoveRight, "right"],
        [[0, 0], [0, 1], Command.MoveLeft, "left"],
        [[1, 0], [0, 0], Command.MoveDown, "down"],
        [[0, 0], [1, 0], Command.MoveUp, "up"]
      ].forEach(([[expectedDown, expectedRight], [startX, startY], command, direction]) => {
          const player = new Player(startX, startY);
          const game = new Game([[1,2],[3,4]], player);
          game.update(command, player);
          assert(expectedDown === game.player.down, `${errMsg} ${direction}`);
          assert(expectedRight === game.player.right, `${errMsg} ${direction}`);
        });
  }
  
  
  
  const Display = {
    GroundTile: Symbol("GroundTile"),
    PlayerTile: Symbol("PlayerTile")
  }
  
  const generateTiles = (game) => {
    checkTypes([Game, game]);
    var tiles = game.map.map((lines) => lines.map(tile => Display.GroundTile));
    tiles[game.player.down][game.player.right] = Display.PlayerTile;
    return tiles;
  };
  
  const render = (tiles) => {
    checkTypes([Array, tiles])
    var tiles = tiles.map((lines) => lines.map(tile => {
        switch(tile){
          case Display.GroundTile:
          return "G";
          case Display.PlayerTile:
          return "P";
        }
      }
      ).join("")).join("\n");
    return tiles;
  };
  
  {
    const assertEqual = (expected, result, message) => {
      if (expected !== result){
        const detailMsg = message ?? "";
        throw new Error(`${detailMsg}: Expected ${result} to be ${expected}`);
      }
    };

    tests = [
      ["generating player tile",
        [
          [0,0], [1,1]
        ],
        ([down, right]) => {
          const result = generateTiles(new Game([[1,2],[3,4]], new Player(down, right)));
          assertEqual(Display.PlayerTile, result[down][right]);
        }
      ],
      ["generating ground tiles",
        [
          [0,0], [1,1]
        ],
        ([down, right]) => {
          const result = generateTiles(new Game([[0,1], [2,3]], new Player(0, 1)));
          assertEqual(Display.GroundTile, result[down][right]);
        }
      ],
      ["rendering tiles",
        [
          ["G\nP", [[Display.GroundTile],[Display.PlayerTile]]
          ]
        ],
        ([expected, tiles]) => {
          const result = render(tiles);
          assertEqual(expected, result);
        }
      ],
      
    ];
  
    var failures = [];
    tests.forEach(([description, dataList, test]) => dataList.forEach((data) => {
        try{
          test(data);
        }
        catch (error) {
          failures.push(`Error ${description} ${error.message}`);
        }
      })
    );
    document.getElementById("test_failures").textContent = failures.join("\n");
  }
  
  const mapElem = document.getElementById("map");
  class Engine {
    constructor(game){
      this.game = game;
      const tiles = generateTiles(game);
      mapElem.textContent = render(tiles);//render initial
    }
    
    progress(command){
      game.update(command);
      const tiles = generateTiles(game);
      mapElem.textContent = render(tiles);
    }
  }
  
  const player = new Player(0, 0);
  const game = new Game([["T", "T"], ["T", "T"]], player);
  const engine = new Engine(game);
  const tiles = generateTiles(game);
  mapElem.textContent = render(tiles);
  
  document.addEventListener("keydown", (event) => {
    switch (event.code) {
      case "KeyH":
        game.update(Command.MoveLrft);
        break;
      case "KeyJ":
        game.update(Command.MoveDown);
        break;
      case "KeyK":
        game.update(Command.MoveUp);
        break;
      case "KeyL":
        game.update(Command.MoveRight);
        break;
    }
  });
  
  document.getElementById("h_button").onclick = (event) => {
    engine.progress(Command.MoveLeft)
  };  
  document.getElementById("j_button").onclick = (event) => {
    engine.progress(Command.MoveDown)
  };  
  document.getElementById("k_button").onclick = (event) => {
    engine.progress(Command.MoveUp)
  };  
  document.getElementById("l_button").onclick = (event) => {
    engine.progress(Command.MoveRight)
  };
}
  
  
</script>
</body>

</html>